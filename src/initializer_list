//----------------------------------------------------------------------------------------------------------------------
// Initializer list
//----------------------------------------------------------------------------------------------------------------------
#pragma once
#ifndef _INITIALIZER_LIST_
#define _INITIALIZER_LIST_

namespace std {
	
	template<class E> class initializer_list {
	public: // Nested types
		using value_type = E;
		using reference = const E&;
		using const_reference = const E&;
		using size_type = size_t;
		using iterator = const E*;
		using const_iterator = const E*;

	public: // Interface
		constexpr initializer_list() noexcept;
		constexpr size_t size() const noexcept { return _end - _start; } ///< number of elements
		constexpr const E* begin() const noexcept { return _start; } ///< first element
		constexpr const E* end() const noexcept { return _end; } ///< one past the last element

	private:
		E* _start = nullptr;
		E* _end = nullptr;
	};	// Initializer list range access
	template<class E> constexpr const E* begin(initializer_list<E> il) noexcept {
		return il.begin();
	}
	template<class E> constexpr const E* end(initializer_list<E> il) noexcept {
		return il.end();
	}
}

#endif // _INITIALIZER_LIST_